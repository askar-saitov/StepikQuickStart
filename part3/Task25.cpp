#include <iostream>
#include <vector>
using namespace std;

int main()
{
    int n, k;
    cin >> n >> k;
    string s; cin >> s;
    int d = 1000000007;    
    vector<int> a(n + 1); // конфигурация стенок
    vector<int> z(n + 1); // кол-во путей до i-ой точки    

    for (int i = 1; i <= n; i++)
        //a[i] = (int)s[i - 1] - 48;
        a[i] = s[i - 1] == '1'? 1: 0;
    
    z[0] = 1; z[1] = 1L - a[1];

    int acc = z[0];
    for (int i = 2; i <= n; i++) {
        acc += z[i - 1]; // добавляем новый крайний правый
        if (i > k) acc -= z[i - 1 - k]; // и вычитаем крайний левый - окно
        acc = ((acc % d) + d) % d; // так нужно для отрицательных чисел
        z[i] = a[i] == 1 ? 0 : acc; // если стенка, то туда 0 путей
    }

    cout << (z[n]);
}

/*
КузнечиК
Перед клетчатой полоской длины n сидит кузнечик.
Каждая клетка является либо занятой, либо свободной.
Кузнечик умеет прыгать на 1, 2, 3 ... k клеткок вперед.
Найдите количество различных путей, которыми он может добраться до последней клетки, не заходя в занятые.
Входные данные
В первой строке записано единственное целое число n (1<=k<=n<=5*10^5).
Во второй строке записана строка длины n, состоящая только из нулей и единиц.
Ноль обозначает свободную клетку, а единица - занятую.
Выходные данные
Выведите единственное число - количество способов добраться до последней клетки.
Поскольку это число может быть очень большим, выведите его по модулю 10^9 + 7.
------
1 1
0
1
------
1 1
1
0
------
2 2
00
2
------
2 1
1
1
------
Sample Input 1:
8 3
01100010
Sample Output 1:
3
Sample Input 2:
8 3
00000001
Sample Output 2:
0
Sample Input 3:
8 4
00111000
Sample Output 3:
4
*/